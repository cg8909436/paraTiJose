<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Que linda te ves hoy Joselyn</title>
<style>
  html,body { height:100%; margin:0; background: #020214; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
  canvas { display:block; width:100%; height:100vh; touch-action: manipulation; }
  .ui {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    text-align: center;
    pointer-events: none;
    padding: 0 10px;
  }
  h1 {
    margin:0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color: #fff4f8;
    font-size: clamp(20px, 5vw, 44px);
    text-shadow: 0 6px 30px rgba(0,0,0,0.8);
    letter-spacing: 0.2px;
    line-height: 1.2;
    max-width: 92vw;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui" aria-hidden="true">
  <h1>Que linda te ves hoy Joselyn, igual estoy molesto contigo, buenas noches ❤️</h1>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  // set canvas CSS size to viewport
  function setCanvasCssSize() {
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }
  setCanvasCssSize();
  window.addEventListener('resize', () => { setCanvasCssSize(); resize(); }, { passive:true });
  resize();

  // ----- Realistic stars + falling stars (meteors) ----
  const W = () => canvas.clientWidth;
  const H = () => canvas.clientHeight;

  // stationary twinkling stars (background)
  let bgStars = [];
  function createBgStars() {
    bgStars = [];
    const bgStarCount = Math.floor((W()*H()) / 7000);
    for (let i=0;i<bgStarCount;i++){
      bgStars.push({
        x: Math.random() * W(),
        y: Math.random() * H(),
        r: Math.random()*1.6 + 0.4,
        twinkleSpeed: 0.5 + Math.random()*1.5,
        phase: Math.random()*Math.PI*2,
        hue: 200 + Math.random()*55,
        sat: 60 + Math.random()*30
      });
    }
  }

  // gentle falling stars (meteors)
  let fallStars = [];
  function createFallStars() {
    fallStars = [];
    const fallCount = Math.max(6, Math.floor(Math.min(W(), H()) / 120));
    for (let i=0;i<fallCount;i++){
      const s = {};
      resetFallStar(s);
      s.y = Math.random() * H();
      fallStars.push(s);
    }
  }

  function resetFallStar(s) {
    s.x = Math.random() * W();
    s.y = -10 - Math.random()*H()*0.2;
    s.len = 8 + Math.random()*28;
    s.speed = 40 + Math.random()*140;
    s.angle = Math.PI*0.25 + (Math.random()-0.5)*0.3;
    s.opacity = 0.6 + Math.random()*0.4;
    s.h = 300 + Math.random()*40;
    s.w = 1 + Math.random()*2.2;
    s.life = 0;
    s.maxLife = 1 + Math.random()*2.2;
  }

  // larger soft-glow stars for depth
  let bigStars = [];
  function createBigStars() {
    bigStars = [];
    const bigCount = Math.max(5, Math.floor(Math.min(W(),H()) / 220));
    for (let i=0;i<bigCount;i++){
      bigStars.push({
        x: Math.random()*W(),
        y: Math.random()*H()*0.6,
        r: 2 + Math.random()*5,
        hue: 210 + Math.random()*40,
        alpha: 0.05 + Math.random()*0.18
      });
    }
  }

  createBgStars();
  createFallStars();
  createBigStars();

  // hearts: realistic pink hearts (parametric path drawing)
  const hearts = [];
  class Heart {
    constructor(x,y,color){
      this.x = x; this.y = y;
      this.t = 0;
      this.life = 0.9 + Math.random()*0.6;
      this.scale = 0.9 + Math.random()*0.9;
      this.rot = (Math.random()-0.5)*0.4;
      this.color = color || 'rgba(255,95,160,1)';
    }
    update(dt){ this.t += dt; }
    alive(){ return this.t < this.life; }
  }

  function drawHeartPath(ctx){
    // draw a heart centered at 0,0 scaled so that base size ~60
    ctx.beginPath();
    ctx.moveTo(0, -30);
    ctx.bezierCurveTo(25, -60, 80, -35, 0, 40);
    ctx.bezierCurveTo(-80, -35, -25, -60, 0, -30);
    ctx.closePath();
  }

  function drawHeart(ctx, x, y, s, color, alpha=1, rotation=0) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(rotation);
    ctx.scale(s, s);
    // soft white core
    ctx.globalAlpha = alpha * 0.20;
    ctx.fillStyle = 'white';
    drawHeartPath(ctx);
    ctx.fill();
    // slight glow
    ctx.globalAlpha = alpha * 0.4;
    ctx.fillStyle = color;
    drawHeartPath(ctx);
    ctx.fill();
    // crisp heart
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    drawHeartPath(ctx);
    ctx.fill();
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // helper to spawn hearts (pink variants)
  function spawnHeart(x,y) {
    hearts.push(new Heart(x,y, 'rgba(255,95,160,1)'));
    // a couple smaller around
    for (let i=0;i<2;i++){
      const rx = x + (Math.random()-0.5)*30;
      const ry = y + (Math.random()-0.5)*30;
      hearts.push(new Heart(rx, ry, 'rgba(255,140,190,1)'));
    }
  }

  // animation loop
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    update(dt);
    render(now/1000);
    requestAnimationFrame(loop);
  }

  function update(dt){
    for (let s of bgStars) s.phase += dt * s.twinkleSpeed;
    for (let fs of fallStars){
      fs.life += dt;
      fs.x += Math.cos(fs.angle) * fs.speed * dt;
      fs.y += Math.sin(fs.angle) * fs.speed * dt;
      if (fs.y > H() + 50 || fs.x > W() + 50) resetFallStar(fs);
    }
    for (let i=hearts.length-1;i>=0;i--){
      hearts[i].update(dt);
      if (!hearts[i].alive()) hearts.splice(i,1);
    }
  }

  function render(time){
    ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
    // gradient sky
    const g = ctx.createLinearGradient(0,0,0,canvas.clientHeight);
    g.addColorStop(0, '#020214');
    g.addColorStop(1, '#05021a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

    // big soft glow stars
    for (let b of bigStars){
      ctx.globalAlpha = b.alpha;
      const grd = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r*10);
      grd.addColorStop(0, `hsla(${b.hue}, 80%, 80%, ${b.alpha})`);
      grd.addColorStop(0.6, `hsla(${b.hue}, 60%, 60%, ${b.alpha*0.5})`);
      grd.addColorStop(1, `hsla(${b.hue}, 40%, 30%, 0)`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r*10, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // small twinkling stars
    for (let s of bgStars){
      const b = 0.45 + 0.55 * (0.5 + 0.5*Math.sin(s.phase));
      ctx.globalAlpha = 0.9 * b;
      ctx.fillStyle = `hsl(${s.hue}, ${s.sat}%, ${60 + Math.floor(30*b)}%)`;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // falling stars (meteors)
    for (let fs of fallStars){
      ctx.globalAlpha = fs.opacity;
      const hx = fs.x;
      const hy = fs.y;
      const headG = ctx.createRadialGradient(hx, hy, 0, hx, hy, fs.len*1.4);
      headG.addColorStop(0, `rgba(255,255,255,${Math.min(1, fs.opacity)})`);
      headG.addColorStop(0.3, `rgba(255,220,200,${fs.opacity*0.6})`);
      headG.addColorStop(1, 'rgba(255,200,150,0)');
      ctx.fillStyle = headG;
      ctx.beginPath();
      ctx.arc(hx, hy, fs.len*0.8, 0, Math.PI*2);
      ctx.fill();
      // trail
      const tx = Math.cos(fs.angle);
      const ty = Math.sin(fs.angle);
      const trailLen = fs.len * 6;
      ctx.save();
      ctx.translate(hx, hy);
      const ang = Math.atan2(ty, tx) + Math.PI;
      ctx.rotate(ang);
      const grad = ctx.createLinearGradient(0, -fs.w*2, -trailLen, fs.w*2);
      grad.addColorStop(0, `rgba(255,255,255,${fs.opacity*0.9})`);
      grad.addColorStop(0.4, `rgba(255,200,170,${fs.opacity*0.5})`);
      grad.addColorStop(1, 'rgba(255,200,170,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(0, -fs.w*2);
      ctx.lineTo(-trailLen, -fs.w*2);
      ctx.lineTo(-trailLen, fs.w*2);
      ctx.lineTo(0, fs.w*2);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    ctx.globalAlpha = 1;

    // hearts on top
    for (let h of hearts){
      const p = (h.t / h.life);
      const ease = Math.sin(p * Math.PI);
      const size = (20 + 36 * ease) * h.scale;
      const alpha = Math.max(0, 1 - p);
      const yy = h.y - (p * 40);
      drawHeart(ctx, h.x, yy, size/60, h.color, alpha, h.rot * (1 - p));
    }
  }

  // input handlers
  function handlePointer(x,y) {
    spawnHeart(x,y);
  }

  canvas.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    for (let t of ev.changedTouches) {
      const rect = canvas.getBoundingClientRect();
      const x = (t.clientX - rect.left);
      const y = (t.clientY - rect.top);
      handlePointer(x,y);
    }
  }, {passive:false});

  canvas.addEventListener('mousedown', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left);
    const y = (ev.clientY - rect.top);
    handlePointer(x,y);
  });

  // responsive: rebuild stars on resize
  window.addEventListener('resize', () => {
    setCanvasCssSize();
    resize();
    createBgStars();
    createFallStars();
    createBigStars();
  });

  requestAnimationFrame(loop);

})(); 
</script>
</body>
</html>
